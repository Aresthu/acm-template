\subsection{次小生成树}
	次小生成树可以由最小生成树换一条边得到。这样就有一种比较容易想到的算法------枚举删除最小生成树上的边，再求最小生成树，然而算法的效率并不是很高。
	
	有一种更简单的方法：先求最小生成树 $T$，枚举添加不在 $T$ 中的边，则添加后一定会形成环。找到环上边值第二大的边 (即环中属于 $T$ 中的最大边)，把它删掉，计算当前生成树的权值，取所有枚举修改的生成树的最小值，即为次小生成树。
	
	这种方法在实现时有更简单的方法：首先求最小生成树 $T$，然后从每个结点 $u$ 遍历最小生成树 $T$，用一个二维数组 $max[u][v]$ 记录结点 $u$ 到结点 $v$ 的路径上边的最大值 (即最大边的值)。然后枚举不在 $T$ 中的边 $(u,v)$，计算 $T-max[u][v]+w(u,v)$ 的最小值，即为次小生成树的权值。显然，这种方法的时间复杂度为 $O(N^{2}+E)$。
	
	\emph{没有代码……}