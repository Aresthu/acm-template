\subsection{第 k 小值}
	如果把“区间最小值”改成“区间第 $k$ 小值”（\emph{假设元素不重复}），那么只好用线段树来解决。
	
	不过线段树需要经过一些处理，使得第 $k$ 小值可以以一种递推的方式来求出。因此，我们可以考虑这样处理每一部分------假设已经知道可能的第 $k$ 小值 $x$，并且统计有多少个数比 $x$ 小。
	
	在合并的时候，如果恰好有 $k−1$ 个数比 $x$ 小, 那么它一定是第 $k$ 小数。如果比 $x$ 小的数太少，说明 $x$ 需要增
	大；如果比 $x$ 小的数太多，则 $x$ 需要减小。这样，只需二分 $x$，每次判断 $x$ 是否为正确答案即可。
	
	\begin{description}
		\item[预处理] 在 “统计有多少个数比 $x$ 小” 之前，先用归并排序将数组排序。设 $A[l,r]$ 表示树内区间 $[l,r]$ 所有元素对应的有序数组。
		\item[查询] 二分答案 $x$，根据比 $x$ 小和相等的元素个数决定 $x$ 应增大还是减小。统计元素个数只需要把分解后的 $2\log _{2}n$ 个区间的统计结果相加，而每个区间的统计需要一次有序数组中的二分查找。假设所有元素均为正整数，且不超过 $C$，则二分次数不超过 $\log C$ 次，总时间复杂度为 $O(\log C\log _{2}n)$\footnote{实际的次数比它小得多，因为二分次数、树中区间个数和树中区间长度都可以远比估计值小。}。
		\item[修改] 在一个有序数组里修改元素可能会很慢，所以为了让修改操作变得快速，需要把有序数组改为排序二叉树。这样，我们得到了一个以排序二叉树为结点的线段树。修改时，从元素对应的线段树的叶结点开始，一直到树根，把每个结点所拥有的排序二叉树的元素更新一下。(删除旧的，增加新的)。时间复杂度为 $\log n+\log(n/2)+\log(n/4)+\cdots=O(\log^2 n)$。
	\end{description}