\subsection{最长公共上升子序列}
	\paragraph{问题} 有两个序列 $a$ 和 $b$。求一个最长的序列 p，使它既是 a 的子序列，又是 b 的子序列，而且，子序列的元素必须是\emph{递增}的。元素之间\emph{不必相邻}。(a,b 长度小于 1000)
	
	\paragraph{思路} 我们可以先保证它是 “公共子序列”。但是，在扩展这个子序列的时候 (也就是上一节中 k=1 的时候) 要好好 “审查” 一下，不要相等就加 1，而是要看看当前位置的值比前面\footnote{因为还有一个 “公共” 的条件，所以找最长序列时可以只关注其中一个序列。}哪个数大，比它大才能加 1。此时状态转移方程可以写成：
	
	\[
		f(i,j)=\left\{{\begin{array}{l}f(i-1,j)\\f(i-1,k)+1(1\leqslant k<j,a[i]=b[j]\land b[j]>b[k])\end{array}}\right.
	\]
	
	时间复杂度为 $O(mn^{2})$。注意，根据以上条件，\emph{答案不一定是 $f(m,n)$}。实际上，$f(m,1)$ 到 $f(m,n)$ 中的最大值才是答案。
	
	\paragraph{优化} 在 $a[i]>b[j]$ 时，我们可以记下 $f(i,j)$ 的最大值 $max$。因为 $b[j]<a[i]$，所以 $b[j']$ 一定可以接在以 $b[j]$ 为结尾的子序列之中。而且，一旦找到与 $a[i]$ 相等的 $b[j']$，那么 $f(i,j')$ 一定等于 $max+1$。
	
	同时，由于我们的上面讨论的 $f(i,j)$ 中的 $i$ 是指的 $a[]$ 的 “前 $i$ 个” 数字。也就是说 $f(i,j)$ 一定包含了 $f(i-1,j)$ 的最优情况或者是比其更优的情况。于是，我们还可以把 $f$ 数组压缩一维，每次仅仅记录 $f(j)$ 就可以了。
	
	经过优化，最终的时间复杂度为 $O(mn)$。
	
	\paragraph{代码} 优化后的代码如下：
	
	\lstinputlisting{ch3/codes/最长公共上升子序列.cpp}