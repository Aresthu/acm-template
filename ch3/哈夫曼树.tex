\subsection{哈夫曼树}
	哈夫曼编码（Huffman Coding）是一种编码方式，是一种用于无损数据压缩的熵编码（权编码）算法。该算法使用变长编码表，概率较高的字母，编码长度较短，反之亦然。
	
	哈夫曼编码值得注意的一点是，一个字符的编码不能是另一个字符编码的前缀，否则会引起歧义。

	哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为 0 层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为 $W_{PL}=(W_1*L_1+W_2*L_2+W_3*L_3+\cdots+W_n*L_n)$，$N$ 个权值 $W_i$ ($i=1,2,\cdots n$) 构成一棵有 $N$ 个叶结点的二叉树，相应的叶结点的路径长度为 $L_i$ ($i=1,2,\cdots n$)。可以证明哈夫曼树的 $W_{PL}$ 是最小的。

	建立哈夫曼树的算法是贪心算法, 其基本思想: (1) 权越大, 离根越近。(2) 自底向上建树。
	
	具体步骤如下:

	\begin{enumerate}
		\item 首先, 创建 $n$ 个初始的 Huffman 树, 每棵树只包含单一的叶结点, 叶结点记录对应字母。
		\item 拿走权最小但没有被处理的两棵树, 再把它们标记为 Huffman 树的叶结点。
		\item 把这两个叶结点标记为一个分支结点的两个子结点, 而这个结点的权即为两个叶结点的权之和。
		\item 重复步骤 2 和 3, 直到序列中只剩下一个元素。
	\end{enumerate}

	调用 makeHuffman 函数时, 需要事先将各个元素的权值放到一个数组中。函数的返回值代表 Huffman 树的根结点。
	
	\lstinputlisting{ch3/codes/哈夫曼树.cpp}