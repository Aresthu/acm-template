% ********************************
% 备注：不保证正确性！
% ********************************
\subsection{树状数组}
	\emph{备注：不保证以下内容是正确的。}

	由于我们只是看两个数之间的大小关系，所以可以对序列中的数进行离散化。即按照大小关系把 $a_1$ 到 $a_n$ 映射到 1 至 $num$ 之间 ($num$ 为不同数字的个数)，保证仍然满足原有的大小关系。
	
	这样，本题就转化成了：对于一个数 $a_i$，在它后面有多少个比它小的数？
	
	处理的时候，我们从第 $n$ 个数倒着处理，用树状数组维护一个 $cnt[]$ 数组，其前缀和 Query($x$) 表示 “到当前处理的第 $i$ 个数为止，映射后值为 1 到 $x$ 之间的数字一共有多少个”，换句话说，如果 $x$ 对应的是 $a[i]$，那么比 $a[i]$ 小的数的个数就是 Query($x-1$)。
	
	对于维护，只要在该次查询结束后进行修改即可，即 Change($x$,1)。整个算法的时间复杂度为 $O(n\log n)$。
	
	\lstinputlisting{ch3/codes/树状数组求逆序对.cpp}