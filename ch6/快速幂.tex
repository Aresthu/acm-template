\subsection{快速幂}
	假设 $a,b$ 均为整数，且 $b>0$。怎样计算 $a^{b}$ 的值?
	
	当然可以使用 <cmath> 里的 pow 函数，不过在取整的时候要注意在结果上加一个小数，即\footnote{比方说 pow(2,10)，正确答案是 1024，但是由于 C++ 的浮点数存在误差，所以最终结果可能是 1024.00000001，也可能是 1023.99999999。对于后者来说，如果直接取整，那么结果就会变成 1023，这是我们不希望看到的。}
	
\begin{lstlisting}
int r = int(pow(2,10) + 0.0001);
\end{lstlisting}
	
	我们也可以使用 for 循环来计算 $a^{b}$，时间复杂度 $O(b)$。显然，这个时间很慢。
	
	实际上我们可以把 $b$ 按照二进制来分解。以 $b=77$ 为例，$77=(1001101)_{2}=2^{6}+2^{3}+2^{2}+2^{0}$。求和的过程可以通过递推来完成，即 $77=(((((1\times 2+0)\times 2+0)\times 2+1)\times 2+1)\times 2+0)\times 2+1$。这样时间复杂度就缩小到 $O(\log b)$ 了。
	
	知道这件事之后，我们就可以通过递推把 $a^{1},a^{4},a^{8},a^{{64}}$ 算出来，然后将它们组合成结果。
	
	\lstinputlisting{ch6/codes/快速幂.cpp}
	
	类似的思想还可以用于求 $a^{1}+a^{2}+a^{3}+a^{4}+\cdots +a^{n}$ 的和，如：
	
	\[ 
		a^{1}+a^{2}+a^{3}+\cdots +a^{{16}}=a^{8}(a^{1}+a^{2}+\cdots +a^{8})+(a^{1}+a^{2}+\cdots +a^{8})
	\]
	
	秦九韶算法也是将多项式计算转化为递推，以缩短计算时间、提高计算精度。