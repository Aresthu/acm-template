\subsection{素数测试}
	朴素算法的时间复杂度为 $O({\sqrt{n}})$，对于某些问题来说结果肯定是很可怕的。下面是一种更快的素数测试法。
	
	\paragraph{费马小定理} 假设 $a$ 是一个整数，$p$ 是一个素数，且 $\gcd(a,p)=1$，则 $a^{p}\equiv a(\mod p),a^{{p-1}}\equiv 1(\mod p)$。
	
	费马小定理的逆命题是不成立的，然而，由于出错的概率比较低，所以我们仍然可以通过它来进行测试。
	
	\paragraph{Miller-Rabin 素数测试} 不断选取 (下面代码只选了四个数) 不超过 $n-1$ 的底数 $a$，每次判断是否为 $a^{{n-1}}\equiv 1(\mod n)$。如果有一次不成立，则 $n$ 为合数，否则\emph{基本上}可以断定为素数（仍然有合数的可能）。
	
	\lstinputlisting{ch6/codes/素数测试(miller-rabin).cpp}
	
	单次 Miller-Rabin 测试的的正确率为 75\%，不过在 $n$ 不太大 $(n\leqslant 2.5\times 10^{{10}})$ 的时候，可以认为 Miller-Rabin 测试是正确的。如果只测试 $a=2,3,5,7$，则通过测试的最小合数为 3,215,031,751；通过 $a=2,3,5,7,11$ 测试的最小合数为 2,152,302,898,747；而通过 $a=2,3,5,7,11,13,17$ 测试的最小合数为 341,550,071,728,321。